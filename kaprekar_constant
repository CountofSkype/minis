"Постоянная Капрекара". Принимает целое число, и запускает "Процесс Капрекара" (если это возможно), выводя на печать каждое число цикла с новой строки до тех пор, пока не будет
получено число Капрекара.

Конечных постоянных Капрекара (таких, которые в результате процесса переходят сами в себя) известно 4: 495, 6174, 549945, 631764.
Для некоторых 6-значных чисел возможно не будет найдена постоянная Капрекара, но процесс "зациклится", т.е. одни и те же числа будут получаться по кругу.
В этом случае необходимо прервать процедуру на первом повторном числе.

Таким образом возможны 3 случая:
Число не удовлетворяет условиям процесса Капрекара - вывести сообщение "Ошибка! На вход подано число {}, не удовлетворяющее условиям процесса Капрекара"
Процесс Капрекара сойдётся к постоянной Капрекара (495, 6174, 549945 или 631764) - вывести на печать все числа, начиная с исходного и до постоянной Капрекара, каждое с новой
строки
Процесс Капрекара зациклится - вывести все числа до момента зацикливания, после чего вывести сообщение "Следующее число - {}, кажется процесс зациклился..."
__________________________________________________________________________________________________________________________________________________________________________________

def number(n):
    return [int(i) for i in str(n)]


def kaprekar_check(n):
    return len(str(n)) in (3, 4, 6) and len(set(str(n))) > 1 and n not in (100, 1000, 100_000)


def kaprekar_step(n):
    x = "".join(map(str, sorted(number(n))))
    return int(x[::-1]) - int(x)


def kaprekar_loop(n):
    if not kaprekar_check(n):
        print(f'Ошибка! На вход подано число {n}, не удовлетворяющее условиям процесса Капрекара')
        return 
    if n in nums:
        print(f'Следующее число - {n}, кажется процесс зациклился...')
        return 
    print(n)
    if n not in (495, 6174, 549945, 631764):
        if len(str(n)) == 6:
                nums.add(n)               
        return kaprekar_loop(kaprekar_step(n))


nums = set()
________________________________________________________________________________________________________________________________________________________________________________

Капрекар установил, что для некоторых чисел верно утверждение:

Квадрат числа можно разбить на две части, сумма которых даёт исходное число. Например, 45 является числом Капрекара, поскольку 45^2=2025 и 20+25=45.
По соглашению, вторая часть может начинаться с 0, но не должна быть нулевой.

Функция принимает на вход натуральное число и возвращает:

True, если число является Числом Капрекара
False, если число НЕ является Числом Капрекара
________________________________________________________________________________________________________________________________________________________________________________

def kaprekar(n):
    sq = str(n ** 2)
    for i in range(1, len(sq)):
        if sq[i:] != '0' * (len(sq) - i) and int(sq[:i]) + int(sq[i:]) == n:
            return True
    return False
________________________________________________________________________________________________________________________________________________________________________________

Функция kaprekar(n, base=10), принимающая на вход натуральное число (int для десятичной системы счисления, либо строку для иной) и основание системы счисления, 
а возвращает:

True, если число является Числом Капрекара
False, если число НЕ является Числом Капрекара
По умолчанию функция считает, что передаваемое число в десятичной системе счисления.
________________________________________________________________________________________________________________________________________________________________________________

def convert(num, to_base=10, from_base=10):
    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    to_10 = 0
    for i in range(len(str(num))):
        to_10 += (alphabet.index(str(num)[::-1][i])) * from_base ** i 
    res = ''
    while to_10 > 0:
        res += alphabet[to_10 % to_base]
        to_10 //= to_base
    return res[::-1]


def kaprekar(n, base=10):
    n = convert(n, 10, base)
    sq = str(int(n) ** 2)
    sq = convert(sq, base, 10)
    for i in range(1, len(sq)):
        if sq[i:] != '0' * (len(sq) - i) and (int(convert(sq[:i], 10, base)) + int(convert(sq[i:], 10, base))) == int(n):
            return True
    return False
